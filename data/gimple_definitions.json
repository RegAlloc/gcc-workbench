{
  "gimple_error_mark": " Error marker.  This is used in similar ways as ERROR_MARK in tree.def.  ",
  "gimple_cond": " GIMPLE_COND <COND_CODE, OP1, OP2, TRUE_LABEL, FALSE_LABEL>  \n   represents the conditional jump:  \n  \n   if (OP1 COND_CODE OP2) goto TRUE_LABEL else goto FALSE_LABEL  \n  \n   COND_CODE is the tree code used as the comparison predicate.  It  \n   must be of class tcc_comparison.  \n  \n   OP1 and OP2 are the operands used in the comparison.  They must be  \n   accepted by is_gimple_operand.  \n  \n   TRUE_LABEL and FALSE_LABEL are the LABEL_DECL nodes used as the  \n   jump target for the comparison.  ",
  "gimple_debug": " GIMPLE_DEBUG represents a debug statement.  ",
  "gimple_goto": " GIMPLE_GOTO <TARGET> represents unconditional jumps.  \n   TARGET is a LABEL_DECL or an expression node for computed GOTOs.  ",
  "gimple_label": " GIMPLE_LABEL <LABEL> represents label statements.  LABEL is a  \n   LABEL_DECL representing a jump target.  ",
  "gimple_switch": " GIMPLE_SWITCH <INDEX, DEFAULT_LAB, LAB1, ..., LABN> represents the  \n   multiway branch:  \n  \n   switch (INDEX)  \n   {  \n     case LAB1: ...; break;  \n     ...  \n     case LABN: ...; break;  \n     default: ...  \n   }  \n  \n   INDEX is the variable evaluated to decide which label to jump to.  \n  \n   DEFAULT_LAB, LAB1 ... LABN are the tree nodes representing case labels.  \n   They must be CASE_LABEL_EXPR nodes.  ",
  "gimple_assign": " GIMPLE_ASSIGN <SUBCODE, LHS, RHS1[, RHS2]> represents the assignment  \n   statement  \n  \n   LHS = RHS1 SUBCODE RHS2.  \n  \n   SUBCODE is the tree code for the expression computed by the RHS of the  \n   assignment.  It must be one of the tree codes accepted by  \n   get_gimple_rhs_class.  If LHS is not a gimple register according to  \n   is_gimple_reg, SUBCODE must be of class GIMPLE_SINGLE_RHS.  \n  \n   LHS is the operand on the LHS of the assignment.  It must be a tree node  \n   accepted by is_gimple_lvalue.  \n  \n   RHS1 is the first operand on the RHS of the assignment.  It must always be  \n   present.  It must be a tree node accepted by is_gimple_val.  \n  \n   RHS2 is the second operand on the RHS of the assignment.  It must be a tree  \n   node accepted by is_gimple_val.  This argument exists only if SUBCODE is  \n   of class GIMPLE_BINARY_RHS.  ",
  "gimple_asm": " GIMPLE_ASM <STRING, I1, ..., IN, O1, ... OM, C1, ..., CP>  \n   represents inline assembly statements.  \n  \n   STRING is the string containing the assembly statements.  \n   I1 ... IN are the N input operands.  \n   O1 ... OM are the M output operands.  \n   C1 ... CP are the P clobber operands.  \n   L1 ... LQ are the Q label operands.  ",
  "gimple_call": " GIMPLE_CALL <FN, LHS, ARG1, ..., ARGN[, CHAIN]> represents function  \n   calls.  \n  \n   FN is the callee.  It must be accepted by is_gimple_call_addr.  \n  \n   LHS is the operand where the return value from FN is stored.  It may  \n   be NULL.  \n  \n   ARG1 ... ARGN are the arguments.  They must all be accepted by  \n   is_gimple_operand.  \n  \n    CHAIN is the optional static chain link for nested functions.  ",
  "gimple_transaction": " GIMPLE_TRANSACTION <BODY, LABEL> represents __transaction_atomic and  \n   __transaction_relaxed blocks.  \n   BODY is the sequence of statements inside the transaction.  \n   LABEL is a label for the statement immediately following the  \n   transaction.  This is before RETURN so that it has MEM_OPS,  \n   so that it can clobber global memory.  ",
  "gimple_return": " GIMPLE_RETURN <RETVAL> represents return statements.  \n  \n   RETVAL is the value to return or NULL.  If a value is returned it  \n   must be accepted by is_gimple_operand.  ",
  "gimple_bind": " GIMPLE_BIND <VARS, BLOCK, BODY> represents a lexical scope.  \n   VARS is the set of variables declared in that scope.  \n   BLOCK is the symbol binding block used for debug information.  \n   BODY is the sequence of statements in the scope.  ",
  "gimple_catch": " GIMPLE_CATCH <TYPES, HANDLER> represents a typed exception handler.  \n   TYPES is the type (or list of types) handled.  HANDLER is the  \n   sequence of statements that handle these types.  ",
  "gimple_eh_filter": " GIMPLE_EH_FILTER <TYPES, FAILURE> represents an exception  \n   specification.  TYPES is a list of allowed types and FAILURE is the  \n   sequence of statements to execute on failure.  ",
  "gimple_eh_must_not_throw": " GIMPLE_EH_MUST_NOT_THROW <DECL> represents an exception barrier.  \n   DECL is a noreturn function decl taking no arguments that will  \n   be invoked if an exception propagates to this point.  ",
  "gimple_eh_else": " GIMPLE_EH_ELSE <N_BODY, E_BODY> must be the sole contents of  \n   a GIMPLE_TRY_FINALLY node.  For all normal exits from the try block,  \n   N_BODY is run; for all exception exits from the try block,  \n   E_BODY is run.  ",
  "gimple_resx": " GIMPLE_RESX resumes execution after an exception.  ",
  "gimple_eh_dispatch": " GIMPLE_EH_DISPATCH demultiplexes an exception edge based on  \n   the FILTER argument.  ",
  "gimple_phi": " GIMPLE_PHI <RESULT, ARG1, ..., ARGN> represents the PHI node  \n  \n   RESULT = PHI <ARG1, ..., ARGN>  \n  \n   RESULT is the SSA name created by this PHI node.  \n  \n   ARG1 ... ARGN are the arguments to the PHI node.  N must be  \n   exactly the same as the number of incoming edges to the basic block  \n   holding the PHI node.  Every argument is either an SSA name or a  \n   tree node of class tcc_constant.  ",
  "gimple_try": " GIMPLE_TRY <TRY_KIND, EVAL, CLEANUP>  \n   represents a try/catch or a try/finally statement.  \n  \n   TRY_KIND is either GIMPLE_TRY_CATCH or GIMPLE_TRY_FINALLY.  \n  \n   EVAL is the sequence of statements to execute on entry to GIMPLE_TRY.  \n  \n   CLEANUP is the sequence of statements to execute according to  \n   TRY_KIND.  If TRY_KIND is GIMPLE_TRY_CATCH, CLEANUP is only exected  \n   if an exception is thrown during execution of EVAL.  If TRY_KIND is  \n   GIMPLE_TRY_FINALLY, CLEANUP is always executed after executing EVAL  \n   (regardless of whether EVAL finished normally, or jumped out or an  \n   exception was thrown).  ",
  "gimple_nop": " GIMPLE_NOP represents the \"do nothing\" statement.  ",
  "gimple_omp_atomic_load": " Tuples used for lowering of OMP_ATOMIC.  Although the form of the OMP_ATOMIC  \n   expression is very simple (just in form mem op= expr), various implicit  \n   conversions may cause the expression to become more complex, so that it does  \n   not fit the gimple grammar very well.  To overcome this problem, OMP_ATOMIC  \n   is rewritten as a sequence of two codes in gimplification:  \n  \n   GIMPLE_OMP_LOAD (tmp, mem)  \n   val = some computations involving tmp;  \n   GIMPLE_OMP_STORE (val).  ",
  "gimple_omp_atomic_store": " Tuples used for lowering of OMP_ATOMIC.  Although the form of the OMP_ATOMIC  \n   expression is very simple (just in form mem op= expr), various implicit  \n   conversions may cause the expression to become more complex, so that it does  \n   not fit the gimple grammar very well.  To overcome this problem, OMP_ATOMIC  \n   is rewritten as a sequence of two codes in gimplification:  \n  \n   GIMPLE_OMP_LOAD (tmp, mem)  \n   val = some computations involving tmp;  \n   GIMPLE_OMP_STORE (val).  ",
  "gimple_omp_continue": " GIMPLE_OMP_CONTINUE marks the location of the loop or sections  \n   iteration in partially lowered OpenMP code.  ",
  "gimple_omp_critical": " GIMPLE_OMP_CRITICAL <NAME, BODY> represents  \n  \n   #pragma omp critical [name]  \n  \n   NAME is the name given to the critical section.  \n   BODY is the sequence of statements that are inside the critical section.  ",
  "gimple_omp_for": " GIMPLE_OMP_FOR <BODY, CLAUSES, INDEX, INITIAL, FINAL, COND, INCR, PRE_BODY>  \n   represents  \n  \n   PRE_BODY  \n   #pragma omp for [clause1 ... clauseN]  \n   for (INDEX = INITIAL; INDEX COND FINAL; INDEX {+=,-=} INCR)  \n   BODY  \n  \n   Likewise for:  \n   #pragma acc loop [clause1 ... clauseN]  \n  \n   BODY is the loop body.  \n  \n   CLAUSES is the list of clauses.  \n  \n   INDEX must be an integer or pointer variable, which is implicitly thread  \n   private.  It must be accepted by is_gimple_operand.  \n  \n   INITIAL is the initial value given to INDEX. It must be  \n   accepted by is_gimple_operand.  \n  \n   FINAL is the final value that INDEX should take. It must  \n   be accepted by is_gimple_operand.  \n  \n   COND is the condition code for the controlling predicate.  It must  \n   be one of { <, >, <=, >= }  \n  \n   INCR is the loop index increment.  It must be tree node of type  \n   tcc_constant.  \n  \n   PRE_BODY is a landing pad filled by the gimplifier with things from  \n   INIT, COND, and INCR that are technically part of the OMP_FOR  \n   structured block, but are evaluated before the loop body begins.  \n  \n   INITIAL, FINAL and INCR are required to be loop invariant integer  \n   expressions that are evaluated without any synchronization.  \n   The evaluation order, frequency of evaluation and side-effects are  \n   unspecified by the standards.  ",
  "gimple_omp_structured_block": " GIMPLE_STRUCTURED_BLOCK <BODY> is an internal construct used to assert  \n   that BODY is a structured block sequence, with no other semantics.  It is  \n   used to allow error-checking of intervening code in OMP_FOR constructs.  ",
  "gimple_omp_master": " GIMPLE_OMP_MASTER <BODY> represents #pragma omp master.  \n   BODY is the sequence of statements to execute in the master section.  ",
  "gimple_omp_masked": " GIMPLE_OMP_MASKED <BODY, CLAUSES> represents #pragma omp masked.  \n   BODY is the sequence of statements to execute in the masked section.  ",
  "gimple_omp_taskgroup": " GIMPLE_OMP_TASKGROUP <BODY, CLAUSES> represents #pragma omp taskgroup.  \n   BODY is the sequence of statements inside the taskgroup section.  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  ",
  "gimple_omp_parallel": " GIMPLE_OMP_PARALLEL <BODY, CLAUSES, CHILD_FN, DATA_ARG> represents  \n  \n   #pragma omp parallel [CLAUSES]  \n   BODY  \n  \n   BODY is a the sequence of statements to be executed by all threads.  \n  \n   CLAUSES is an OMP_CLAUSE chain with all the clauses.  \n  \n   CHILD_FN is set when outlining the body of the parallel region.  \n   All the statements in BODY are moved into this newly created  \n   function when converting OMP constructs into low-GIMPLE.  \n  \n   DATA_ARG is a local variable in the parent function containing data  \n   to be shared with CHILD_FN.  This is used to implement all the data  \n   sharing clauses.  ",
  "gimple_omp_task": " GIMPLE_OMP_TASK <BODY, CLAUSES, CHILD_FN, DATA_ARG, COPY_FN,  \n\t\t    ARG_SIZE, ARG_ALIGN> represents  \n  \n   #pragma omp task [CLAUSES]  \n   BODY  \n  \n   BODY is a the sequence of statements to be executed by all threads.  \n  \n   CLAUSES is an OMP_CLAUSE chain with all the clauses.  \n  \n   CHILD_FN is set when outlining the body of the explicit task region.  \n   All the statements in BODY are moved into this newly created  \n   function when converting OMP constructs into low-GIMPLE.  \n  \n   DATA_ARG is a local variable in the parent function containing data  \n   to be shared with CHILD_FN.  This is used to implement all the data  \n   sharing clauses.  \n  \n   COPY_FN is set when outlining the firstprivate var initialization.  \n   All the needed statements are emitted into the newly created  \n   function, or when only memcpy is needed, it is NULL.  \n  \n   ARG_SIZE and ARG_ALIGN are the size and alignment of the incoming  \n   data area allocated by GOMP_task and passed to CHILD_FN.  ",
  "gimple_omp_return": " OMP_RETURN marks the end of an OpenMP directive.  ",
  "gimple_omp_scan": " GIMPLE_OMP_SCAN <BODY, CLAUSES> represents #pragma omp scan  \n   BODY is the sequence of statements inside the single section.  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  ",
  "gimple_omp_scope": " GIMPLE_OMP_SCOPE <BODY, CLAUSES> represents #pragma omp scope  \n   BODY is the sequence of statements inside the single section.  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  ",
  "gimple_omp_dispatch": " GIMPLE_OMP_DISPATCH <BODY, CLAUSES> represents #pragma omp dispatch  \n   BODY is the target function call to be dispatched.  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  ",
  "gimple_omp_interop": " GIMPLE_OMP_INTEROP <CLAUSES> represents #pragma omp interop  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  ",
  "gimple_omp_section": " OMP_SECTION <BODY> represents #pragma omp section.  \n   BODY is the sequence of statements in the section body.  ",
  "gimple_omp_sections": " OMP_SECTIONS <BODY, CLAUSES, CONTROL> represents #pragma omp sections.  \n  \n   BODY is the sequence of statements in the sections body.  \n   CLAUSES is an OMP_CLAUSE chain holding the list of associated clauses.  \n   CONTROL is a VAR_DECL used for deciding which of the sections  \n   to execute.  ",
  "gimple_omp_sections_switch": " GIMPLE_OMP_SECTIONS_SWITCH is a marker placed immediately after  \n   OMP_SECTIONS.  It represents the GIMPLE_SWITCH used to decide which  \n   branch is taken.  ",
  "gimple_omp_single": " GIMPLE_OMP_SINGLE <BODY, CLAUSES> represents #pragma omp single  \n   BODY is the sequence of statements inside the single section.  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  ",
  "gimple_omp_target": " GIMPLE_OMP_TARGET <BODY, CLAUSES, CHILD_FN> represents  \n   #pragma acc {kernels,parallel,serial,data,enter data,exit data,update}  \n   #pragma omp target {,data,update}  \n   BODY is the sequence of statements inside the construct  \n   (NULL for some variants).  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  \n   CHILD_FN is set when outlining the body of the offloaded region.  \n   All the statements in BODY are moved into this newly created  \n   function when converting OMP constructs into low-GIMPLE.  \n   DATA_ARG is a vec of 3 local variables in the parent function  \n   containing data to be mapped to CHILD_FN.  This is used to  \n   implement the MAP clauses.  ",
  "gimple_omp_teams": " GIMPLE_OMP_TEAMS <BODY, CLAUSES, CHILD_FN, DATA_ARG> represents  \n   #pragma omp teams  \n   BODY is the sequence of statements inside the single section.  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  \n   CHILD_FN and DATA_ARG like for GIMPLE_OMP_PARALLEL.  ",
  "gimple_omp_ordered": " GIMPLE_OMP_ORDERED <BODY, CLAUSES> represents #pragma omp ordered.  \n   BODY is the sequence of statements to execute in the ordered section.  \n   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  ",
  "gimple_predict": " GIMPLE_PREDICT <PREDICT, OUTCOME> specifies a hint for branch prediction.  \n  \n   PREDICT is one of the predictors from predict.def.  \n  \n   OUTCOME is NOT_TAKEN or TAKEN.  ",
  "gimple_with_cleanup_expr": "  This node represents a cleanup expression.  It is ONLY USED INTERNALLY  \n    by the gimplifier as a placeholder for cleanups, and its uses will be  \n    cleaned up by the time gimplification is done.  \n  \n    This tuple should not exist outside of the gimplifier proper.  ",
  "gimple_assume": " GIMPLE_ASSUME <GUARD, BODY> represents [[assume(cond)]].  \n   BODY is the GIMPLE_BIND with the condition which sets GUARD to true  \n   (otherwise UB).  ",
  "error_mark": " Any erroneous construct is parsed into a node of this type.  \n   This type of node is accepted without complaint in all contexts  \n   by later parsing activities, to avoid multiple error messages  \n   for one error.  \n   No fields in these nodes are used except the TREE_CODE.  ",
  "identifier_node": " Used to represent a name (such as, in the DECL_NAME of a decl node).  \n   Internally it looks like a STRING_CST node.  \n   There is only one IDENTIFIER_NODE ever made for any particular name.  \n   Use `get_identifier' to get it (or create it, the first time).  ",
  "tree_list": " These nodes are made into lists by chaining through the  \n   TREE_CHAIN field.  The elements of the list live in the  \n   TREE_VALUE fields, while TREE_PURPOSE fields are occasionally  \n   used as well to get the effect of Lisp association lists.  ",
  "tree_vec": " These nodes contain an array of tree nodes.  ",
  "block": " A symbol binding block.  These are arranged in a tree,  \n   where the BLOCK_SUBBLOCKS field contains a chain of subblocks  \n   chained through the BLOCK_CHAIN field.  \n   BLOCK_SUPERCONTEXT points to the parent block.  \n     For a block which represents the outermost scope of a function, it  \n     points to the FUNCTION_DECL node.  \n   BLOCK_VARS points to a chain of decl nodes.  \n   BLOCK_CHAIN points to the next BLOCK at the same level.  \n   BLOCK_ABSTRACT_ORIGIN points to the original (abstract) tree node which  \n   this block is an instance of, or else is NULL to indicate that this  \n   block is not an instance of anything else.  When non-NULL, the value  \n   could either point to another BLOCK node or it could point to a  \n   FUNCTION_DECL node (e.g. in the case of a block representing the  \n   outermost scope of a particular inlining of a function).  \n   TREE_ASM_WRITTEN is nonzero if the block was actually referenced  \n   in the generated assembly.  ",
  "offset_type": " An offset is a pointer relative to an object.  \n   The TREE_TYPE field is the type of the object at the offset.  \n   The TYPE_OFFSET_BASETYPE points to the node for the type of object  \n   that the offset is relative to.  ",
  "enumeral_type": " A forward reference `enum foo' when no enum named foo is defined yet  \n   has zero (a null pointer) in its TYPE_SIZE.  The tag name is in  \n   the TYPE_NAME field.  If the type is later defined, the normal  \n   fields are filled in.  \n   RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE forward refs are  \n   treated similarly.  ",
  "boolean_type": " Boolean type (true or false are the only values).  Looks like an  \n   INTEGER_TYPE, but must be dealt with specially because TYPE_PRECISION  \n   may be arbitrary despite the restricted set of valid values (in other  \n   words, boolean types with TYPE_PRECISION > 1 exist in some languages).  \n   Similarly, TYPE_UNSIGNED may be false for components of vector masks,  \n   as well as for boolean types in languages other than C.  ",
  "integer_type": " Integer types in all languages, including char in C.  \n   Also used for sub-ranges of other discrete types.  \n   Has components TYPE_MIN_VALUE, TYPE_MAX_VALUE (expressions, inclusive)  \n   and TYPE_PRECISION (number of bits used by this type).  ",
  "bitint_type": " Bit-precise integer type.  These are similar to INTEGER_TYPEs, but  \n   can have arbitrary user selected precisions and do or can have different  \n   alignment, function argument and return value passing conventions.  \n   Larger BITINT_TYPEs can have BLKmode TYPE_MODE and need to be lowered  \n   by a special BITINT_TYPE lowering pass.  ",
  "real_type": " C's float and double.  Different floating types are distinguished  \n   by machine mode and by the TYPE_SIZE and the TYPE_PRECISION.  ",
  "pointer_type": " All pointer-to-x types have code POINTER_TYPE.  \n   The TREE_TYPE points to the node for the type pointed to.  ",
  "reference_type": " A reference is like a pointer except that it is coerced  \n   automatically to the value it points to.  Used in C++.  ",
  "nullptr_type": " The C++ decltype(nullptr) type.  ",
  "fixed_point_type": " _Fract and _Accum types in Embedded-C.  Different fixed-point types  \n   are distinguished by machine mode and by the TYPE_SIZE and the  \n   TYPE_PRECISION.  ",
  "complex_type": " Complex number types.  The TREE_TYPE field is the data type  \n   of the real and imaginary parts.  It must be of scalar  \n   arithmetic type, not including pointer type.  ",
  "vector_type": " Vector types.  The TREE_TYPE field is the data type of the vector  \n   elements.  The TYPE_PRECISION field is the number of subparts of  \n   the vector.  ",
  "array_type": " Array types in C ",
  "record_type": " See the comment above, before ENUMERAL_TYPE, for how  \n   forward references to struct tags are handled in C.  ",
  "union_type": " See the comment above, before ENUMERAL_TYPE, for how  \n   forward references to union tags are handled in C.  ",
  "qual_union_type": " Similar to UNION_TYPE, except that the expressions in DECL_QUALIFIER  \n   in each FIELD_DECL determine what the union contains.  The first  \n   field whose DECL_QUALIFIER expression is true is deemed to occupy  \n   the union.  ",
  "void_type": " The void type in C ",
  "function_type": " Type of functions.  Special fields:  \n   TREE_TYPE\t\t    type of value returned.  \n   TYPE_ARG_TYPES      list of types of arguments expected.  \n\tthis list is made of TREE_LIST nodes.  \n\tIn this list TREE_PURPOSE can be used to indicate the default  \n\tvalue of parameter (used by C++ frontend).  \n   Types of \"Procedures\" in languages where they are different from functions  \n   have code FUNCTION_TYPE also, but then TREE_TYPE is zero or void type.  ",
  "method_type": " METHOD_TYPE is the type of a function which takes an extra first  \n   argument for \"self\", which is not present in the declared argument list.  \n   The TREE_TYPE is the return type of the method.  The TYPE_METHOD_BASETYPE  \n   is the type of \"self\".  TYPE_ARG_TYPES is the real argument list, which  \n   includes the hidden argument for \"self\".  ",
  "lang_type": " This is a language-specific kind of type.  \n   Its meaning is defined by the language front end.  \n   layout_type does not know how to lay this out,  \n   so the front-end must do so manually.  ",
  "opaque_type": " This is for types that will use MODE_OPAQUE in the back end.  They are meant  \n   to be able to go in a register of some sort but are explicitly not to be  \n   converted or operated on like INTEGER_TYPE.  They will have size and  \n   alignment information only.  ",
  "void_cst": "**void_cst**",
  "integer_cst": " Contents are in an array of HOST_WIDE_INTs.  \n  \n   We often access these constants both in their native precision and  \n   in wider precisions (with the constant being implicitly extended  \n   according to TYPE_SIGN).  In each case, the useful part of the array  \n   may be as wide as the precision requires but may be shorter when all  \n   of the upper bits are sign bits.  The length of the array when accessed  \n   in the constant's native precision is given by TREE_INT_CST_NUNITS.  \n   The length of the array when accessed in wider precisions is given  \n   by TREE_INT_CST_EXT_NUNITS.  Each element can be obtained using  \n   TREE_INT_CST_ELT.  \n  \n   INTEGER_CST nodes can be shared, and therefore should be considered  \n   read only.  They should be copied before setting a flag such as  \n   TREE_OVERFLOW.  If an INTEGER_CST has TREE_OVERFLOW already set,  \n   it is known to be unique.  INTEGER_CST nodes are created for the  \n   integral types, for pointer types and for vector and float types in  \n   some circumstances.  ",
  "poly_int_cst": " Contents are given by POLY_INT_CST_COEFF.  ",
  "real_cst": " Contents are in TREE_REAL_CST field.  ",
  "fixed_cst": " Contents are in TREE_FIXED_CST field.  ",
  "complex_cst": " Contents are in TREE_REALPART and TREE_IMAGPART fields,  \n   whose contents are other constant nodes.  ",
  "vector_cst": " See generic.texi for details.  ",
  "string_cst": " Contents are TREE_STRING_LENGTH and the actual contents of the string.  ",
  "raw_data_cst": " Contents are RAW_DATA_LENGTH and the actual content  \n   of the raw data, plus RAW_DATA_OWNER for owner of the  \n   data.  That can be either a STRING_CST, used e.g. when writing  \n   PCH header, or another RAW_DATA_CST representing data owned by  \n   libcpp and representing the original range (if possible)  \n   or NULL_TREE if it is the RAW_DATA_OWNER of other RAW_DATA_CST  \n   nodes (and represents data owned by libcpp).  \n   TREE_TYPE is the type of each of the RAW_DATA_LENGTH elements.  ",
  "function_decl": "**function_decl**",
  "label_decl": "**function_decl**",
  "field_decl": " The ordering of the following codes is optimized for the checking  \n   macros in tree.h.  Changing the order will degrade the speed of the  \n   compiler.  FIELD_DECL, VAR_DECL, CONST_DECL, PARM_DECL,  \n   TYPE_DECL.  ",
  "var_decl": " The ordering of the following codes is optimized for the checking  \n   macros in tree.h.  Changing the order will degrade the speed of the  \n   compiler.  FIELD_DECL, VAR_DECL, CONST_DECL, PARM_DECL,  \n   TYPE_DECL.  ",
  "const_decl": " The ordering of the following codes is optimized for the checking  \n   macros in tree.h.  Changing the order will degrade the speed of the  \n   compiler.  FIELD_DECL, VAR_DECL, CONST_DECL, PARM_DECL,  \n   TYPE_DECL.  ",
  "parm_decl": " The ordering of the following codes is optimized for the checking  \n   macros in tree.h.  Changing the order will degrade the speed of the  \n   compiler.  FIELD_DECL, VAR_DECL, CONST_DECL, PARM_DECL,  \n   TYPE_DECL.  ",
  "type_decl": " The ordering of the following codes is optimized for the checking  \n   macros in tree.h.  Changing the order will degrade the speed of the  \n   compiler.  FIELD_DECL, VAR_DECL, CONST_DECL, PARM_DECL,  \n   TYPE_DECL.  ",
  "result_decl": " The ordering of the following codes is optimized for the checking  \n   macros in tree.h.  Changing the order will degrade the speed of the  \n   compiler.  FIELD_DECL, VAR_DECL, CONST_DECL, PARM_DECL,  \n   TYPE_DECL.  ",
  "debug_expr_decl": " A \"declaration\" of a debug temporary.  It should only appear in  \n   DEBUG stmts.  ",
  "debug_begin_stmt": " A stmt that marks the beginning of a source statement.  ",
  "namespace_decl": " A namespace declaration.  Namespaces appear in DECL_CONTEXT of other  \n   _DECLs, providing a hierarchy of names.  ",
  "imported_decl": " A declaration import.  \n   The C++ FE uses this to represent a using-directive; eg:  \n   \"using namespace foo\".  \n   But it could be used to represent any declaration import construct.  \n   Whenever a declaration import appears in a lexical block, the BLOCK node  \n   representing that lexical block in GIMPLE will contain an IMPORTED_DECL  \n   node, linked via BLOCK_VARS accessor of the said BLOCK.  \n   For a given NODE which code is IMPORTED_DECL,  \n   IMPORTED_DECL_ASSOCIATED_DECL (NODE) accesses the imported declaration.  ",
  "namelist_decl": " A namelist declaration.  \n   The Fortran FE uses this to represent a namelist statement, e.g.:  \n   NAMELIST /namelist-group-name/ namelist-group-object-list.  \n   Whenever a declaration import appears in a lexical block, the BLOCK node  \n   representing that lexical block in GIMPLE will contain an NAMELIST_DECL  \n   node, linked via BLOCK_VARS accessor of the said BLOCK.  \n   For a given NODE which code is NAMELIST_DECL,  \n   NAMELIST_DECL_ASSOCIATED_DECL (NODE) accesses the imported declaration.  ",
  "translation_unit_decl": " A translation unit.  This is not technically a declaration, since it  \n   can't be looked up, but it's close enough.  ",
  "component_ref": " Value is structure or union component.  \n   Operand 0 is the structure or union (an expression).  \n   Operand 1 is the field (a node of type FIELD_DECL).  \n   Operand 2, if present, is the value of DECL_FIELD_OFFSET, measured  \n   in units of DECL_OFFSET_ALIGN / BITS_PER_UNIT.  ",
  "bit_field_ref": " Reference to a group of bits within an object.  Similar to COMPONENT_REF  \n   except the position is given explicitly rather than via a FIELD_DECL.  \n   Operand 0 is the structure or union expression;  \n   operand 1 is a tree giving the constant number of bits being referenced;  \n   operand 2 is a tree giving the constant position of the first referenced bit.  \n   The result type width has to match the number of bits referenced.  \n   If the result type is integral, its signedness specifies how it is extended  \n   to its mode width.  ",
  "array_ref": " Array indexing.  \n   Operand 0 is the array; operand 1 is a (single) array index.  \n   Operand 2, if present, is a copy of TYPE_MIN_VALUE of the index.  \n   Operand 3, if present, is the element size, measured in units of  \n   the alignment of the element type.  ",
  "array_range_ref": " Likewise, except that the result is a range (\"slice\") of the array.  The  \n   starting index of the resulting array is taken from operand 1 and the size  \n   of the range is taken from the type of the expression.  ",
  "realpart_expr": " Used only on an operand of complex type, these return  \n   a value of the corresponding component type.  ",
  "imagpart_expr": " Used only on an operand of complex type, these return  \n   a value of the corresponding component type.  ",
  "view_convert_expr": " Represents viewing something of one type as being of a second type.  \n   This corresponds to an \"Unchecked Conversion\" in Ada and roughly to  \n   the idiom *(type2 *)&X in C.  The only operand is the value to be  \n   viewed as being of another type.  It is undefined if the type of the  \n   input and of the expression have different sizes.  \n  \n   This code may also be used within the LHS of a MODIFY_EXPR, in which  \n   case no actual data motion may occur.  TREE_ADDRESSABLE will be set in  \n   this case and GCC must abort if it could not do the operation without  \n   generating insns.  ",
  "indirect_ref": " C unary `*'.  One operand, an expression for a pointer.  ",
  "obj_type_ref": " Used to represent lookup in a virtual method table which is dependent on  \n   the runtime type of an object.  Operands are:  \n   OBJ_TYPE_REF_EXPR: An expression that evaluates the value to use.  \n   OBJ_TYPE_REF_OBJECT: Is the object on whose behalf the lookup is  \n   being performed.  Through this the optimizers may be able to statically  \n   determine the dynamic type of the object.  \n   OBJ_TYPE_REF_TOKEN: An integer index to the virtual method table.  \n   The integer index should have as type the original type of  \n   OBJ_TYPE_REF_OBJECT; as pointer type conversions are useless in GIMPLE,  \n   the type of OBJ_TYPE_REF_OBJECT can change to an unrelated pointer  \n   type during optimizations.  ",
  "constructor": " Used to represent the brace-enclosed initializers for a structure or an  \n   array.  It contains a sequence of component values made out of a VEC of  \n   constructor_elt.  \n  \n   For RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE:  \n   The field INDEX of each constructor_elt is a FIELD_DECL.  \n  \n   For ARRAY_TYPE:  \n   The field INDEX of each constructor_elt is the corresponding index.  \n   If the index is a RANGE_EXPR, it is a short-hand for many nodes,  \n   one for each index in the range.  (If the corresponding field VALUE  \n   has side-effects, they are evaluated once for each element.  Wrap the  \n   value in a SAVE_EXPR if you want to evaluate side effects only once.)  \n   If the index is INTEGER_CST or NULL_TREE and value RAW_DATA_CST, it is  \n   a short-hand for RAW_DATA_LENGTH consecutive nodes, first at the given  \n   index or current location, each node being  \n   build_int_cst (TREE_TYPE (value), TYPE_UNSIGNED (TREE_TYPE (value))  \n\t\t  ? (HOST_WIDE_INT) RAW_DATA_UCHAR_ELT (value, n)  \n\t\t  : (HOST_WIDE_INT) RAW_DATA_SCHAR_ELT (value, n)) at index  \n   tree_to_uhwi (index) + n (or current location + n) for n from 0 to  \n   RAW_DATA_LENGTH (value) - 1.  \n  \n   Components that aren't present are cleared as per the C semantics,  \n   unless the CONSTRUCTOR_NO_CLEARING flag is set, in which case their  \n   value becomes undefined.  ",
  "compound_expr": " Contains two expressions to compute, one followed by the other.  \n   the first value is ignored.  The second one's value is used.  The  \n   type of the first expression need not agree with the other types.  ",
  "modify_expr": " Assignment expression.  Operand 0 is the what to set; 1, the new value.  ",
  "init_expr": " Initialization expression.  Operand 0 is the variable to initialize;  \n   Operand 1 is the initializer.  This differs from MODIFY_EXPR in that any  \n   reference to the referent of operand 0 within operand 1 is undefined.  ",
  "target_expr": " For TARGET_EXPR, operand 0 is the target of an initialization,  \n   operand 1 is the initializer for the target, which may be void  \n     if simply expanding it initializes the target.  \n   operand 2 is the cleanup for this node, if any.  \n   operand 3 is the saved initializer after this node has been  \n   expanded once; this is so we can re-expand the tree later.  ",
  "cond_expr": " Conditional expression ( ... ? ... : ...  in C).  \n   Operand 0 is the condition.  \n   Operand 1 is the then-value.  \n   Operand 2 is the else-value.  \n   Operand 0 may be of any type.  \n   Operand 1 must have the same type as the entire expression, unless  \n   it unconditionally throws an exception, in which case it should  \n   have VOID_TYPE.  The same constraints apply to operand 2.  The  \n   condition in operand 0 must be of integral type.  \n  \n   In cfg gimple, if you do not have a selection expression, operands  \n   1 and 2 are NULL.  The operands are then taken from the cfg edges. ",
  "vec_duplicate_expr": " Represents a vector in which every element is equal to operand 0.  ",
  "vec_series_expr": " Vector series created from a start (base) value and a step.  \n  \n   A = VEC_SERIES_EXPR (B, C)  \n  \n   means  \n  \n   for (i = 0; i < N; i++)  \n     A[i] = B + C * i;  ",
  "vec_cond_expr": " Vector conditional expression. It is like COND_EXPR, but with  \n   vector operands.  \n  \n   A = VEC_COND_EXPR ( X < Y, B, C)  \n  \n   means  \n  \n   for (i=0; i<N; i++)  \n     A[i] = X[i] < Y[i] ? B[i] : C[i];",
  "vec_perm_expr": " Vector permutation expression.  A = VEC_PERM_EXPR<v0, v1, mask> means  \n  \n   N = length(mask)  \n   foreach i in N:  \n     M = mask[i] % (length(v0) + length(v1))  \n     A[i] = M < length(v0) ? v0[M] : v1[M - length(v0)]  \n  \n   V0 and V1 are vectors of the same type.  \n  \n   When MASK is not constant:  \n     MASK is an integer-typed vector.  The number of MASK elements must  \n     be the same as the number of elements in V0 and V1.  The size of  \n     the inner type of the MASK and of the V0 and V1 must be the same.  \n  \n   When MASK is constant:  \n     MASK is an integer-typed vector.",
  "bind_expr": " Declare local variables, including making RTL and allocating space.  \n   BIND_EXPR_VARS is a chain of VAR_DECL nodes for the variables.  \n   BIND_EXPR_BODY is the body, the expression to be computed using  \n   the variables.  The value of operand 1 becomes that of the BIND_EXPR.  \n   BIND_EXPR_BLOCK is the BLOCK that corresponds to these bindings  \n   for debugging purposes.  If this BIND_EXPR is actually expanded,  \n   that sets the TREE_USED flag in the BLOCK.  \n  \n   The BIND_EXPR is not responsible for informing parsers  \n   about these variables.  If the body is coming from the input file,  \n   then the code that creates the BIND_EXPR is also responsible for  \n   informing the parser of the variables.  \n  \n   If the BIND_EXPR is ever expanded, its TREE_USED flag is set.  \n   This tells the code for debugging symbol tables not to ignore the BIND_EXPR.  \n   If the BIND_EXPR should be output for debugging but will not be expanded,  \n   set the TREE_USED flag by hand.  \n  \n   In order for the BIND_EXPR to be known at all, the code that creates it  \n   must also install it as a subblock in the tree of BLOCK  \n   nodes for the function.  ",
  "call_expr": " Function call.  CALL_EXPRs are represented by variably-sized expression  \n   nodes.  There are at least three fixed operands.  Operand 0 is an  \n   INTEGER_CST node containing the total operand count, the number of  \n   arguments plus 3.  Operand 1 is the function or NULL, while operand 2 is  \n   is static chain argument, or NULL.  The remaining operands are the  \n   arguments to the call.  ",
  "with_cleanup_expr": " Specify a value to compute along with its corresponding cleanup.  \n   Operand 0 is the cleanup expression.  \n   The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR,  \n   which must exist.  This differs from TRY_CATCH_EXPR in that operand 1  \n   is always evaluated when cleanups are run.  ",
  "cleanup_point_expr": " Specify a cleanup point.  \n   Operand 0 is an expression that may have cleanups.  If it does, those  \n   cleanups are executed after the expression is expanded.  \n  \n   Note that if the expression is a reference to storage, it is forced out  \n   of memory before the cleanups are run.  This is necessary to handle  \n   cases where the cleanups modify the storage referenced; in the  \n   expression 't.i', if 't' is a struct with an integer member 'i' and a  \n   cleanup which modifies 'i', the value of the expression depends on  \n   whether the cleanup is run before or after 't.i' is evaluated.  When  \n   expand_expr is run on 't.i', it returns a MEM.  This is not good enough;  \n   the value of 't.i' must be forced out of memory.  \n  \n   As a consequence, the operand of a CLEANUP_POINT_EXPR must not have  \n   BLKmode, because it will not be forced out of memory.  ",
  "placeholder_expr": " Denotes a record to later be substituted before evaluating this expression.  \n   The type of this expression is used to find the record to replace it.  ",
  "plus_expr": " Simple arithmetic.  ",
  "minus_expr": " Simple arithmetic.  ",
  "mult_expr": " Simple arithmetic.  ",
  "pointer_plus_expr": " Pointer addition.  The first operand is always a pointer and the  \n   second operand is an integer of type sizetype.  ",
  "pointer_diff_expr": " Pointer subtraction.  The two arguments are pointers, and the result  \n   is a signed integer of the same precision.  Pointers are interpreted  \n   as unsigned, the difference is computed as if in infinite signed  \n   precision.  Behavior is undefined if the difference does not fit in  \n   the result type.  The result does not depend on the pointer type,  \n   it is not divided by the size of the pointed-to type.  ",
  "mult_highpart_expr": " Highpart multiplication.  For an integral type with precision B,  \n   returns bits [2B-1, B] of the full 2*B product.  Both operands  \n   and the result should have integer types of the same precision  \n   and signedness.  ",
  "trunc_div_expr": " Division for integer result that rounds the quotient toward zero.  ",
  "ceil_div_expr": " Division for integer result that rounds it toward plus infinity.  ",
  "floor_div_expr": " Division for integer result that rounds it toward minus infinity.  ",
  "round_div_expr": " Division for integer result that rounds it toward nearest integer.  ",
  "trunc_mod_expr": " The sign of the remainder is that of the dividend.  ",
  "ceil_mod_expr": " The sign of the remainder is the opposite of that of the divisor.  ",
  "floor_mod_expr": " The sign of the remainder is that of the divisor.  ",
  "round_mod_expr": " The sign of the remainder is not predictable.  ",
  "rdiv_expr": " Division for real result.  ",
  "exact_div_expr": " Division which is not supposed to need rounding.  \n   Used for pointer subtraction in C.  ",
  "fix_trunc_expr": " Conversion of real to fixed point by truncation.  ",
  "float_expr": " Conversion of an integer to a real.  ",
  "negate_expr": " Unary negation.  ",
  "min_expr": " Minimum and maximum values.  When used with floating point, if both  \n   operands are zeros, or if either operand is NaN, then it is unspecified  \n   which of the two operands is returned as the result.  ",
  "max_expr": " Minimum and maximum values.  When used with floating point, if both  \n   operands are zeros, or if either operand is NaN, then it is unspecified  \n   which of the two operands is returned as the result.  ",
  "abs_expr": " Represents the absolute value of the operand.  \n  \n   An ABS_EXPR must have either an INTEGER_TYPE or a REAL_TYPE.  The  \n   operand of the ABS_EXPR must have the same type.  ",
  "absu_expr": " Represents the unsigned absolute value of the operand.  \n   An ABSU_EXPR must have unsigned INTEGER_TYPE.  The operand of the ABSU_EXPR  \n   must have the corresponding signed type.  ",
  "lshift_expr": " Shift operations for shift and rotate.  \n   Shift means logical shift if done on an  \n   unsigned type, arithmetic shift if done on a signed type.  \n   The second operand is the number of bits to  \n   shift by; it need not be the same type as the first operand and result.  \n   Note that the result is undefined if the second operand is larger  \n   than or equal to the first operand's type size.  \n  \n   The first operand of a shift can have either an integer or a  \n   (non-integer) fixed-point type.  We follow the ISO/IEC TR 18037:2004  \n   semantics for the latter.  \n  \n   Rotates are defined for integer types only.  ",
  "rshift_expr": " Shift operations for shift and rotate.  \n   Shift means logical shift if done on an  \n   unsigned type, arithmetic shift if done on a signed type.  \n   The second operand is the number of bits to  \n   shift by; it need not be the same type as the first operand and result.  \n   Note that the result is undefined if the second operand is larger  \n   than or equal to the first operand's type size.  \n  \n   The first operand of a shift can have either an integer or a  \n   (non-integer) fixed-point type.  We follow the ISO/IEC TR 18037:2004  \n   semantics for the latter.  \n  \n   Rotates are defined for integer types only.  ",
  "lrotate_expr": " Shift operations for shift and rotate.  \n   Shift means logical shift if done on an  \n   unsigned type, arithmetic shift if done on a signed type.  \n   The second operand is the number of bits to  \n   shift by; it need not be the same type as the first operand and result.  \n   Note that the result is undefined if the second operand is larger  \n   than or equal to the first operand's type size.  \n  \n   The first operand of a shift can have either an integer or a  \n   (non-integer) fixed-point type.  We follow the ISO/IEC TR 18037:2004  \n   semantics for the latter.  \n  \n   Rotates are defined for integer types only.  ",
  "rrotate_expr": " Shift operations for shift and rotate.  \n   Shift means logical shift if done on an  \n   unsigned type, arithmetic shift if done on a signed type.  \n   The second operand is the number of bits to  \n   shift by; it need not be the same type as the first operand and result.  \n   Note that the result is undefined if the second operand is larger  \n   than or equal to the first operand's type size.  \n  \n   The first operand of a shift can have either an integer or a  \n   (non-integer) fixed-point type.  We follow the ISO/IEC TR 18037:2004  \n   semantics for the latter.  \n  \n   Rotates are defined for integer types only.  ",
  "bit_ior_expr": " Bitwise operations.  Operands have same mode as result.  ",
  "bit_xor_expr": " Bitwise operations.  Operands have same mode as result.  ",
  "bit_and_expr": " Bitwise operations.  Operands have same mode as result.  ",
  "bit_not_expr": " Bitwise operations.  Operands have same mode as result.  ",
  "truth_andif_expr": " ANDIF and ORIF allow the second operand not to be computed if the  \n   value of the expression is determined from the first operand.  AND,  \n   OR, and XOR always compute the second operand whether its value is  \n   needed or not (for side effects).  The operand may have  \n   BOOLEAN_TYPE or INTEGER_TYPE.  In either case, the argument will be  \n   either zero or one.  For example, a TRUTH_NOT_EXPR will never have  \n   an INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be  \n   used to compare the VAR_DECL to zero, thereby obtaining a node with  \n   value zero or one.  ",
  "truth_orif_expr": " ANDIF and ORIF allow the second operand not to be computed if the  \n   value of the expression is determined from the first operand.  AND,  \n   OR, and XOR always compute the second operand whether its value is  \n   needed or not (for side effects).  The operand may have  \n   BOOLEAN_TYPE or INTEGER_TYPE.  In either case, the argument will be  \n   either zero or one.  For example, a TRUTH_NOT_EXPR will never have  \n   an INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be  \n   used to compare the VAR_DECL to zero, thereby obtaining a node with  \n   value zero or one.  ",
  "truth_and_expr": " ANDIF and ORIF allow the second operand not to be computed if the  \n   value of the expression is determined from the first operand.  AND,  \n   OR, and XOR always compute the second operand whether its value is  \n   needed or not (for side effects).  The operand may have  \n   BOOLEAN_TYPE or INTEGER_TYPE.  In either case, the argument will be  \n   either zero or one.  For example, a TRUTH_NOT_EXPR will never have  \n   an INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be  \n   used to compare the VAR_DECL to zero, thereby obtaining a node with  \n   value zero or one.  ",
  "truth_or_expr": " ANDIF and ORIF allow the second operand not to be computed if the  \n   value of the expression is determined from the first operand.  AND,  \n   OR, and XOR always compute the second operand whether its value is  \n   needed or not (for side effects).  The operand may have  \n   BOOLEAN_TYPE or INTEGER_TYPE.  In either case, the argument will be  \n   either zero or one.  For example, a TRUTH_NOT_EXPR will never have  \n   an INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be  \n   used to compare the VAR_DECL to zero, thereby obtaining a node with  \n   value zero or one.  ",
  "truth_xor_expr": " ANDIF and ORIF allow the second operand not to be computed if the  \n   value of the expression is determined from the first operand.  AND,  \n   OR, and XOR always compute the second operand whether its value is  \n   needed or not (for side effects).  The operand may have  \n   BOOLEAN_TYPE or INTEGER_TYPE.  In either case, the argument will be  \n   either zero or one.  For example, a TRUTH_NOT_EXPR will never have  \n   an INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be  \n   used to compare the VAR_DECL to zero, thereby obtaining a node with  \n   value zero or one.  ",
  "truth_not_expr": " ANDIF and ORIF allow the second operand not to be computed if the  \n   value of the expression is determined from the first operand.  AND,  \n   OR, and XOR always compute the second operand whether its value is  \n   needed or not (for side effects).  The operand may have  \n   BOOLEAN_TYPE or INTEGER_TYPE.  In either case, the argument will be  \n   either zero or one.  For example, a TRUTH_NOT_EXPR will never have  \n   an INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be  \n   used to compare the VAR_DECL to zero, thereby obtaining a node with  \n   value zero or one.  ",
  "lt_expr": " Relational operators.  \n   EQ_EXPR and NE_EXPR are allowed for any types.  The others, except for  \n   LTGT_EXPR, are allowed only for integral, floating-point and vector types.  \n   LTGT_EXPR is allowed only for floating-point types.  \n   For floating-point operators, if either operand is a NaN, then NE_EXPR  \n   returns true and the remaining operators return false.  The operators  \n   other than EQ_EXPR and NE_EXPR may generate an exception on quiet NaNs.  \n   In all cases the operands will have the same type,  \n   and the value is either the type used by the language for booleans  \n   or an integer vector type of the same size and with the same number  \n   of elements as the comparison operands.  True for a vector of  \n   comparison results has all bits set while false is equal to zero.  ",
  "le_expr": " Relational operators.  \n   EQ_EXPR and NE_EXPR are allowed for any types.  The others, except for  \n   LTGT_EXPR, are allowed only for integral, floating-point and vector types.  \n   LTGT_EXPR is allowed only for floating-point types.  \n   For floating-point operators, if either operand is a NaN, then NE_EXPR  \n   returns true and the remaining operators return false.  The operators  \n   other than EQ_EXPR and NE_EXPR may generate an exception on quiet NaNs.  \n   In all cases the operands will have the same type,  \n   and the value is either the type used by the language for booleans  \n   or an integer vector type of the same size and with the same number  \n   of elements as the comparison operands.  True for a vector of  \n   comparison results has all bits set while false is equal to zero.  ",
  "gt_expr": " Relational operators.  \n   EQ_EXPR and NE_EXPR are allowed for any types.  The others, except for  \n   LTGT_EXPR, are allowed only for integral, floating-point and vector types.  \n   LTGT_EXPR is allowed only for floating-point types.  \n   For floating-point operators, if either operand is a NaN, then NE_EXPR  \n   returns true and the remaining operators return false.  The operators  \n   other than EQ_EXPR and NE_EXPR may generate an exception on quiet NaNs.  \n   In all cases the operands will have the same type,  \n   and the value is either the type used by the language for booleans  \n   or an integer vector type of the same size and with the same number  \n   of elements as the comparison operands.  True for a vector of  \n   comparison results has all bits set while false is equal to zero.  ",
  "ge_expr": " Relational operators.  \n   EQ_EXPR and NE_EXPR are allowed for any types.  The others, except for  \n   LTGT_EXPR, are allowed only for integral, floating-point and vector types.  \n   LTGT_EXPR is allowed only for floating-point types.  \n   For floating-point operators, if either operand is a NaN, then NE_EXPR  \n   returns true and the remaining operators return false.  The operators  \n   other than EQ_EXPR and NE_EXPR may generate an exception on quiet NaNs.  \n   In all cases the operands will have the same type,  \n   and the value is either the type used by the language for booleans  \n   or an integer vector type of the same size and with the same number  \n   of elements as the comparison operands.  True for a vector of  \n   comparison results has all bits set while false is equal to zero.  ",
  "ltgt_expr": " Relational operators.  \n   EQ_EXPR and NE_EXPR are allowed for any types.  The others, except for  \n   LTGT_EXPR, are allowed only for integral, floating-point and vector types.  \n   LTGT_EXPR is allowed only for floating-point types.  \n   For floating-point operators, if either operand is a NaN, then NE_EXPR  \n   returns true and the remaining operators return false.  The operators  \n   other than EQ_EXPR and NE_EXPR may generate an exception on quiet NaNs.  \n   In all cases the operands will have the same type,  \n   and the value is either the type used by the language for booleans  \n   or an integer vector type of the same size and with the same number  \n   of elements as the comparison operands.  True for a vector of  \n   comparison results has all bits set while false is equal to zero.  ",
  "eq_expr": " Relational operators.  \n   EQ_EXPR and NE_EXPR are allowed for any types.  The others, except for  \n   LTGT_EXPR, are allowed only for integral, floating-point and vector types.  \n   LTGT_EXPR is allowed only for floating-point types.  \n   For floating-point operators, if either operand is a NaN, then NE_EXPR  \n   returns true and the remaining operators return false.  The operators  \n   other than EQ_EXPR and NE_EXPR may generate an exception on quiet NaNs.  \n   In all cases the operands will have the same type,  \n   and the value is either the type used by the language for booleans  \n   or an integer vector type of the same size and with the same number  \n   of elements as the comparison operands.  True for a vector of  \n   comparison results has all bits set while false is equal to zero.  ",
  "ne_expr": " Relational operators.  \n   EQ_EXPR and NE_EXPR are allowed for any types.  The others, except for  \n   LTGT_EXPR, are allowed only for integral, floating-point and vector types.  \n   LTGT_EXPR is allowed only for floating-point types.  \n   For floating-point operators, if either operand is a NaN, then NE_EXPR  \n   returns true and the remaining operators return false.  The operators  \n   other than EQ_EXPR and NE_EXPR may generate an exception on quiet NaNs.  \n   In all cases the operands will have the same type,  \n   and the value is either the type used by the language for booleans  \n   or an integer vector type of the same size and with the same number  \n   of elements as the comparison operands.  True for a vector of  \n   comparison results has all bits set while false is equal to zero.  ",
  "unordered_expr": " Additional relational operators for floating-point unordered.  ",
  "ordered_expr": " Additional relational operators for floating-point unordered.  ",
  "unlt_expr": " These are equivalent to unordered or ...  ",
  "unle_expr": " These are equivalent to unordered or ...  ",
  "ungt_expr": " These are equivalent to unordered or ...  ",
  "unge_expr": " These are equivalent to unordered or ...  ",
  "uneq_expr": " These are equivalent to unordered or ...  ",
  "range_expr": "**range_expr**",
  "paren_expr": " Represents a re-association barrier for floating point expressions  \n   like explicit parenthesis in fortran.  ",
  "convert_expr": " Represents a conversion of type of a value.  \n   All conversions, including implicit ones, must be  \n   represented by CONVERT_EXPR or NOP_EXPR nodes.  ",
  "addr_space_convert_expr": " Conversion of a pointer value to a pointer to a different  \n   address space.  ",
  "fixed_convert_expr": " Conversion of a fixed-point value to an integer, a real, or a fixed-point  \n   value.  Or conversion of a fixed-point value from an integer, a real, or  \n   a fixed-point value.  ",
  "nop_expr": " Represents a conversion expected to require no code to be generated.  ",
  "non_lvalue_expr": " Value is same as argument, but guaranteed not an lvalue.  ",
  "compound_literal_expr": " A COMPOUND_LITERAL_EXPR represents a literal that is placed in a DECL.  The  \n   COMPOUND_LITERAL_EXPR_DECL_EXPR is the a DECL_EXPR containing the decl  \n   for the anonymous object represented by the COMPOUND_LITERAL;  \n   the DECL_INITIAL of that decl is the CONSTRUCTOR that initializes  \n   the compound literal.  ",
  "save_expr": " Represents something we computed once and will use multiple times.  \n   First operand is that expression.  After it is evaluated once, it  \n   will be replaced by the temporary variable that holds the value.  ",
  "addr_expr": " & in C.  Value is the address at which the operand's value resides.  \n   Operand may have any mode.  Result mode is Pmode.  ",
  "fdesc_expr": " Operand0 is a function constant; result is part N of a function  \n   descriptor of type ptr_mode.  ",
  "bit_insert_expr": " Given a container value, a replacement value and a bit position within  \n   the container, produce the value that results from replacing the part of  \n   the container starting at the bit position with the replacement value.  \n   Operand 0 is a tree for the container value of integral or vector type;  \n   Operand 1 is a tree for the replacement value of another integral or  \n   the vector element type;  \n   Operand 2 is a tree giving the constant bit position;  \n   The number of bits replaced is given by the precision of the type of the  \n   replacement value if it is integral or by its size if it is non-integral.  \n   ???  The reason to make the size of the replacement implicit is to avoid  \n   introducing a quaternary operation.  \n   The replaced bits shall be fully inside the container.  If the container  \n   is of vector type, then these bits shall be aligned with its elements.  ",
  "complex_expr": " Given two real or integer operands of the same type,  \n   returns a complex value of the corresponding complex type.  ",
  "conj_expr": " Complex conjugate of operand.  Used only on complex types.  ",
  "predecrement_expr": " Nodes for ++ and -- in C.  \n   The second arg is how much to increment or decrement by.  \n   For a pointer, it would be the size of the object pointed to.  ",
  "preincrement_expr": " Nodes for ++ and -- in C.  \n   The second arg is how much to increment or decrement by.  \n   For a pointer, it would be the size of the object pointed to.  ",
  "postdecrement_expr": " Nodes for ++ and -- in C.  \n   The second arg is how much to increment or decrement by.  \n   For a pointer, it would be the size of the object pointed to.  ",
  "postincrement_expr": " Nodes for ++ and -- in C.  \n   The second arg is how much to increment or decrement by.  \n   For a pointer, it would be the size of the object pointed to.  ",
  "va_arg_expr": " Used to implement `va_arg'.  ",
  "try_catch_expr": " Evaluate operand 0.  If and only if an exception is thrown during  \n   the evaluation of operand 0, evaluate operand 1.  \n  \n   This differs from TRY_FINALLY_EXPR in that operand 1 is not evaluated  \n   on a normal or jump exit, only on an exception.  ",
  "try_finally_expr": " Evaluate the first operand.  \n   The second operand is a cleanup expression which is evaluated  \n   on any exit (normal, exception, or jump out) from this expression.  ",
  "eh_else_expr": " Evaluate either the normal or the exceptional cleanup.  This must  \n   only be present as the cleanup expression in a TRY_FINALLY_EXPR.  \n   If the TRY_FINALLY_EXPR completes normally, the first operand of  \n   EH_ELSE_EXPR is used as a cleanup, otherwise the second operand is  \n   used.  ",
  "decl_expr": " Used to represent a local declaration. The operand is DECL_EXPR_DECL.  ",
  "label_expr": " A label definition, encapsulated as a statement.  \n   Operand 0 is the LABEL_DECL node for the label that appears here.  \n   The type should be void and the value should be ignored.  ",
  "goto_expr": " GOTO.  Operand 0 is a LABEL_DECL node or an expression.  \n   The type should be void and the value should be ignored.  ",
  "return_expr": " RETURN.  Evaluates operand 0, then returns from the current function.  \n   Presumably that operand is an assignment that stores into the  \n   RESULT_DECL that hold the value to be returned.  \n   The operand may be null.  \n   The type should be void and the value should be ignored.  ",
  "exit_expr": " Exit the inner most loop conditionally.  Operand 0 is the condition.  \n   The type should be void and the value should be ignored.  ",
  "loop_expr": " A loop.  Operand 0 is the body of the loop.  \n   It must contain an EXIT_EXPR or is an infinite loop.  \n   The type should be void and the value should be ignored.  ",
  "switch_expr": " Switch expression.  \n  \n   TREE_TYPE is the original type of the condition, before any  \n   language required type conversions.  It may be NULL, in which case  \n   the original type and final types are assumed to be the same.  \n  \n   Operand 0 is the expression used to perform the branch,  \n   Operand 1 is the body of the switch, which probably contains  \n     CASE_LABEL_EXPRs.  It may also be NULL, in which case operand 2  \n     must not be NULL.  ",
  "case_label_expr": " Used to represent a case label.  \n  \n   Operand 0 is CASE_LOW.  It may be NULL_TREE, in which case the label  \n     is a 'default' label.  \n   Operand 1 is CASE_HIGH.  If it is NULL_TREE, the label is a simple  \n     (one-value) case label.  If it is non-NULL_TREE, the case is a range.  \n   Operand 2 is CASE_LABEL, which has the corresponding LABEL_DECL.  \n   Operand 3 is CASE_CHAIN.  This operand is only used in tree-cfg.cc to  \n     speed up the lookup of case labels which use a particular edge in  \n     the control flow graph.  ",
  "asm_expr": " Used to represent an inline assembly statement.  ASM_STRING returns a  \n   STRING_CST for the instruction (e.g., \"mov x, y\"). ASM_OUTPUTS,  \n   ASM_INPUTS, and ASM_CLOBBERS represent the outputs, inputs, and clobbers  \n   for the statement.  ASM_LABELS, if present, indicates various destinations  \n   for the asm; labels cannot be combined with outputs.  ",
  "ssa_name": " Variable references for SSA analysis.  New SSA names are created every  \n   time a variable is assigned a new value.  The SSA builder uses SSA_NAME  \n   nodes to implement SSA versioning.  ",
  "catch_expr": " Used to represent a typed exception handler.  CATCH_TYPES is the type (or  \n   list of types) handled, and CATCH_BODY is the code for the handler.  ",
  "eh_filter_expr": " Used to represent an exception specification.  EH_FILTER_TYPES is a list  \n   of allowed types, and EH_FILTER_FAILURE is an expression to evaluate on  \n   failure.  ",
  "scev_known": " Node used for describing a property that is known at compile  \n   time.  ",
  "scev_not_known": " Node used for describing a property that is not known at compile  \n   time.  ",
  "polynomial_chrec": " Polynomial chains of recurrences.  \n   cr = {CHREC_LEFT (cr), +, CHREC_RIGHT (cr)}_CHREC_VARIABLE (cr).  ",
  "statement_list": " Used to chain children of container statements together.  \n   Use the interface in tree-iterator.h to access this node.  ",
  "assert_expr": " NOTE: This code is deprecated and should only be used internally by ipa* as  \n   temporary construct.  \n  \n   Predicate assertion.  Artificial expression generated by the optimizers  \n   to keep track of predicate values.  This expression may only appear on  \n   the RHS of assignments.  \n  \n   Given X = ASSERT_EXPR <Y, EXPR>, the optimizers can infer  \n   two things:  \n  \n   \t1- X is a copy of Y.  \n\t2- EXPR is a conditional expression and is known to be true.  \n  \n   Valid and to be expected forms of conditional expressions are  \n   valid GIMPLE conditional expressions (as defined by is_gimple_condexpr)  \n   and conditional expressions with the first operand being a  \n   PLUS_EXPR with a variable possibly wrapped in a NOP_EXPR first  \n   operand and an integer constant second operand.  \n  \n   The type of the expression is the same as Y.  ",
  "tree_binfo": " Base class information. Holds information about a class as a  \n   baseclass of itself or another class.  ",
  "with_size_expr": " Records the size for an expression of variable size type.  This is  \n   for use in contexts in which we are accessing the entire object,  \n   such as for a function call, or block copy.  \n   Operand 0 is the real expression.  \n   Operand 1 is the size of the type in the expression.  ",
  "realign_load": " Extract elements from two input vectors Operand 0 and Operand 1  \n   size VS, according to the offset OFF defined by Operand 2 as  \n   follows:  \n   If OFF > 0, the last VS - OFF elements of vector OP0 are concatenated to  \n   the first OFF elements of the vector OP1.  \n   If OFF == 0, then the returned vector is OP1.  \n   On different targets OFF may take different forms; It can be an address, in  \n   which case its low log2(VS)-1 bits define the offset, or it can be a mask  \n   generated by the builtin targetm.vectorize.mask_for_load_builtin_decl.  ",
  "target_mem_ref": "**target_mem_ref**",
  "mem_ref": " Memory addressing.  Operands are a pointer and a tree constant integer  \n   byte offset of the pointer type that when dereferenced yields the  \n   type of the base object the pointer points into and which is used for  \n   TBAA purposes.  \n   The type of the MEM_REF is the type the bytes at the memory location  \n   are interpreted as.  \n   MEM_REF <p, c> is equivalent to ((typeof(c))p)->x... where x... is a  \n   chain of component references offsetting p by c.  ",
  "oacc_parallel": "**oacc_parallel**",
  "oacc_kernels": "**oacc_kernels**",
  "oacc_serial": "**oacc_serial**",
  "oacc_data": "**oacc_data**",
  "oacc_host_data": "**oacc_host_data**",
  "omp_parallel": "**omp_parallel**",
  "omp_task": "**omp_task**",
  "omp_for": "**omp_for**",
  "omp_simd": " OpenMP - #pragma omp simd [clause1 ... clauseN]  \n   Operands like for OMP_FOR.  ",
  "omp_distribute": " OpenMP - #pragma omp distribute [clause1 ... clauseN]  \n   Operands like for OMP_FOR.  ",
  "omp_taskloop": " OpenMP - #pragma omp taskloop [clause1 ... clauseN]  \n   Operands like for OMP_FOR.  ",
  "omp_loop": " OpenMP - #pragma omp loop [clause1 ... clauseN]  \n   Operands like for OMP_FOR.  ",
  "omp_tile": " OpenMP - #pragma omp tile [clause1 ... clauseN]  \n   Operands like for OMP_FOR.  ",
  "omp_unroll": " OpenMP - #pragma omp unroll [clause1 ... clauseN]  \n   Operands like for OMP_FOR.  ",
  "oacc_loop": " OpenACC - #pragma acc loop [clause1 ... clauseN]  \n   Operands like for OMP_FOR.  ",
  "omp_teams": " OpenMP - #pragma omp teams [clause1 ... clauseN]  \n   Operand 0: OMP_TEAMS_BODY: Teams body.  \n   Operand 1: OMP_TEAMS_CLAUSES: List of clauses.  ",
  "omp_target_data": " OpenMP - #pragma omp target data [clause1 ... clauseN]  \n   Operand 0: OMP_TARGET_DATA_BODY: Target data construct body.  \n   Operand 1: OMP_TARGET_DATA_CLAUSES: List of clauses.  ",
  "omp_target": " OpenMP - #pragma omp target [clause1 ... clauseN]  \n   Operand 0: OMP_TARGET_BODY: Target construct body.  \n   Operand 1: OMP_TARGET_CLAUSES: List of clauses.  ",
  "omp_sections": " OpenMP - #pragma omp sections [clause1 ... clauseN]  \n   Operand 0: OMP_SECTIONS_BODY: Sections body.  \n   Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.  ",
  "omp_ordered": " OpenMP - #pragma omp ordered  \n   Operand 0: OMP_ORDERED_BODY: Master section body.  \n   Operand 1: OMP_ORDERED_CLAUSES: List of clauses.  ",
  "omp_critical": " OpenMP - #pragma omp critical [name]  \n   Operand 0: OMP_CRITICAL_BODY: Critical section body.  \n   Operand 1: OMP_CRITICAL_CLAUSES: List of clauses.  \n   Operand 2: OMP_CRITICAL_NAME: Identifier for critical section.  ",
  "omp_single": " OpenMP - #pragma omp single  \n   Operand 0: OMP_SINGLE_BODY: Single section body.  \n   Operand 1: OMP_SINGLE_CLAUSES: List of clauses.  ",
  "omp_scope": " OpenMP - #pragma omp scope  \n   Operand 0: OMP_SCOPE_BODY: Masked section body.  \n   Operand 1: OMP_SCOPE_CLAUSES: List of clauses.  ",
  "omp_taskgroup": " OpenMP - #pragma omp taskgroup  \n   Operand 0: OMP_TASKGROUP_BODY: Taskgroup body.  \n   Operand 1: OMP_SINGLE_CLAUSES: List of clauses.  ",
  "omp_masked": " OpenMP - #pragma omp masked  \n   Operand 0: OMP_MASKED_BODY: Masked section body.  \n   Operand 1: OMP_MASKED_CLAUSES: List of clauses.  ",
  "omp_scan": " OpenMP - #pragma omp scan  \n   Operand 0: OMP_SCAN_BODY: Scan body.  \n   Operand 1: OMP_SCAN_CLAUSES: List of clauses.  ",
  "omp_dispatch": " OpenMP - #pragma omp dispatch [clause1 ... clauseN]  \n   Operand 0: OMP_DISPATCH_BODY: Expression statement including a target call.  \n   Operand 1: OMP_DISPATCH_CLAUSES: List of clauses.  ",
  "omp_inteorp": " OpenMP - #pragma omp interop [clause1 ... clauseN]  \n   Operand 0: OMP_INTEROP_CLAUSES: List of clauses.  ",
  "omp_section": " OpenMP - #pragma omp section  \n   Operand 0: OMP_SECTION_BODY: Section body.  ",
  "omp_structured_block": " OpenMP structured block sequences that don't correspond to the body  \n   another directive.  This is used for code fragments within the body  \n   of a directive that are separately required to be structured block  \n   sequence; in particular, for intervening code sequences in  \n   imperfectly-nested loops.  \n   Operand 0: BODY: contains the statement(s) within the structured block  \n   sequence.  ",
  "omp_master": " OpenMP - #pragma omp master  \n   Operand 0: OMP_MASTER_BODY: Master section body.  ",
  "omp_declare_mapper": " OpenMP - #pragma omp declare mapper ([id:] type var) [clause1 ... clauseN]  \n   Operand 0: Identifier.  \n   Operand 1: Variable decl.  \n   Operand 2: List of clauses.  \n   The type of the construct is used for the type to be mapped.  ",
  "oacc_cache": " OpenACC - #pragma acc cache (variable1 ... variableN)  \n   Operand 0: OACC_CACHE_CLAUSES: List of variables (transformed into  \n\tOMP_CLAUSE__CACHE_ clauses).  ",
  "oacc_declare": " OpenACC - #pragma acc declare [clause1 ... clauseN]  \n   Operand 0: OACC_DECLARE_CLAUSES: List of clauses.  ",
  "oacc_enter_data": " OpenACC - #pragma acc enter data [clause1 ... clauseN]  \n   Operand 0: OACC_ENTER_DATA_CLAUSES: List of clauses.  ",
  "oacc_exit_data": " OpenACC - #pragma acc exit data [clause1 ... clauseN]  \n   Operand 0: OACC_EXIT_DATA_CLAUSES: List of clauses.  ",
  "oacc_update": " OpenACC - #pragma acc update [clause1 ... clauseN]  \n   Operand 0: OACC_UPDATE_CLAUSES: List of clauses.  ",
  "omp_target_update": " OpenMP - #pragma omp target update [clause1 ... clauseN]  \n   Operand 0: OMP_TARGET_UPDATE_CLAUSES: List of clauses.  ",
  "omp_target_enter_data": " OpenMP - #pragma omp target enter data [clause1 ... clauseN]  \n   Operand 0: OMP_TARGET_ENTER_DATA_CLAUSES: List of clauses.  ",
  "omp_target_exit_data": " OpenMP - #pragma omp target exit data [clause1 ... clauseN]  \n   Operand 0: OMP_TARGET_EXIT_DATA_CLAUSES: List of clauses.  ",
  "omp_metadirective": " OpenMP - #pragma omp metadirective [variant1 ... variantN]  \n   Operand 0: OMP_METADIRECTIVE_VARIANTS: List of selectors and directive  \n   variants.  The variants are internally TREE_LISTs, but use  \n   make_omp_metadirective_variant to build them.  ",
  "omp_atomic": " OpenMP - #pragma omp atomic  \n   Operand 0: The address at which the atomic operation is to be performed.  \n\tThis address should be stabilized with save_expr.  \n   Operand 1: The expression to evaluate.  When the old value of the object  \n\tat the address is used in the expression, it should appear as if  \n\tbuild_fold_indirect_ref of the address.  ",
  "omp_atomic_read": " OpenMP - #pragma omp atomic read  \n   Operand 0: The address at which the atomic operation is to be performed.  \n\tThis address should be stabilized with save_expr.  ",
  "omp_atomic_capture_old": " OpenMP - #pragma omp atomic capture  \n   Operand 0: The address at which the atomic operation is to be performed.  \n\tThis address should be stabilized with save_expr.  \n   Operand 1: The expression to evaluate.  When the old value of the object  \n\tat the address is used in the expression, it should appear as if  \n\tbuild_fold_indirect_ref of the address.  \n   OMP_ATOMIC_CAPTURE_OLD returns the old memory content,  \n   OMP_ATOMIC_CAPTURE_NEW the new value.  ",
  "omp_atomic_capture_new": " OpenMP - #pragma omp atomic capture  \n   Operand 0: The address at which the atomic operation is to be performed.  \n\tThis address should be stabilized with save_expr.  \n   Operand 1: The expression to evaluate.  When the old value of the object  \n\tat the address is used in the expression, it should appear as if  \n\tbuild_fold_indirect_ref of the address.  \n   OMP_ATOMIC_CAPTURE_OLD returns the old memory content,  \n   OMP_ATOMIC_CAPTURE_NEW the new value.  ",
  "omp_clause": " OpenMP clauses.  ",
  "omp_array_section": " An OpenMP array section.  ",
  "omp_next_variant": " OpenMP variant construct selector, used only in the middle end in the  \n   expansions of variant constructs that can't be resolved until the  \n   ompdevlow pass.  These variants are converted into switch expressions  \n   that use OMP_NEXT_VARIANT as a placeholder for the index of next variant  \n   to try if a dynamic selector does not match.  The ompdevlow pass  \n   replaces these nodes with constant integers after resolution.  \n   Operand 0: OMP_NEXT_VARIANT_INDEX: an INTEGER_CST holding the switch  \n   index of the current variant.  \n   Operand 1: OMP_NEXT_VARIANT_STATE: a TREE_LIST that is shared among all  \n   OMP_NEXT_VARIANT expressions for the same variant directive.  The  \n   TREE_PURPOSE of this node holds the resolved lookup table, while  \n   TREE_VALUE holds the saved construct context and TREE_CHAIN the  \n   original vector of selectors that are used to fill in the table.  ",
  "omp_target_device_matches": " OpenMP target_device match placeholder, similarly used only in the middle  \n   end in the expansions of variant constructs that need to be resolved in  \n   the ompdevlow pass.  \n   Operand 0: OMP_TARGET_DEVICE_MATCHES_SELECTOR: INTEGER_CST encoding one  \n   of OMP_TRAIT_DEVICE_KIND, OMP_TRAIT_DEVICE_ARCH, or OMP_TRAIT_DEVICE_ISA.  \n   Operand 1: OMP_TARGET_DEVICE_MATCHES_PROPERTIES: A TREE_LIST of strings  \n   and/or identifiers, corresponding to the OMP_TS_PROPERTIES for the trait  \n   selector.  \n   This resolves to a boolean truth value if the properties match the  \n   trait selector for the offload compiler.  ",
  "transaction_expr": " TRANSACTION_EXPR tree code.  \n   Operand 0: BODY: contains body of the transaction.  ",
  "dot_prod_expr": " Widening dot-product.  \n   The first two arguments are of type t1.  \n   The third argument and the result are of type t2, such that t2 is at least  \n   twice the size of t1. DOT_PROD_EXPR(arg1,arg2,arg3) is equivalent to:  \n   \ttmp = WIDEN_MULT_EXPR(arg1, arg2);  \n   \targ3 = PLUS_EXPR (tmp, arg3);  \n   or:  \n\ttmp = WIDEN_MULT_EXPR(arg1, arg2);  \n        arg3 = WIDEN_SUM_EXPR (tmp, arg3);\t\t ",
  "widen_sum_expr": " Widening summation.  \n   The first argument is of type t1.  \n   The second argument is of type t2, such that t2 is at least twice  \n   the size of t1. The type of the entire expression is also t2.  \n   WIDEN_SUM_EXPR is equivalent to first widening (promoting)  \n   the first argument from type t1 to type t2, and then summing it  \n   with the second argument.  ",
  "sad_expr": " Widening sad (sum of absolute differences).  \n   The first two arguments are of type t1 which should be a vector of integers.  \n   The third argument and the result are of type t2, such that the size of  \n   the elements of t2 is at least twice the size of the elements of t1.  \n   Like DOT_PROD_EXPR, SAD_EXPR (arg1,arg2,arg3) is  \n   equivalent to:  \n       tmp = IFN_VEC_WIDEN_MINUS_EXPR (arg1, arg2)  \n       tmp2 = ABS_EXPR (tmp)  \n       arg3 = PLUS_EXPR (tmp2, arg3)  \n  or:  \n       tmp = IFN_VEC_WIDEN_MINUS_EXPR (arg1, arg2)  \n       tmp2 = ABS_EXPR (tmp)  \n       arg3 = WIDEN_SUM_EXPR (tmp2, arg3)",
  "widen_mult_expr": " Widening multiplication.  \n   The two arguments are of type t1 and t2, both integral types that  \n   have the same precision, but possibly different signedness.  \n   The result is of integral type t3, such that t3 is at least twice  \n   the size of t1/t2. WIDEN_MULT_EXPR is equivalent to first widening  \n   (promoting) the arguments from type t1 to type t3, and from t2 to  \n   type t3 and then multiplying them.  ",
  "widen_mult_plus_expr": " Widening multiply-accumulate.  \n   The first two arguments are of type t1.  \n   The third argument and the result are of type t2, such as t2 is at least  \n   twice the size of t1.  t1 and t2 must be integral or fixed-point types.  \n   The expression is equivalent to a WIDEN_MULT_EXPR operation  \n   of the first two operands followed by an add or subtract of the third  \n   operand.  ",
  "widen_mult_minus_expr": " This is like the above, except in the final expression the multiply result  \n   is subtracted from t3.  ",
  "widen_lshift_expr": " Widening shift left.  \n   The first operand is of type t1.  \n   The second operand is the number of bits to shift by; it need not be the  \n   same type as the first operand and result.  \n   Note that the result is undefined if the second operand is larger  \n   than or equal to the first operand's type size.  \n   The type of the entire expression is t2, such that t2 is at least twice  \n   the size of t1.  \n   WIDEN_LSHIFT_EXPR is equivalent to first widening (promoting)  \n   the first argument from type t1 to type t2, and then shifting it  \n   by the second argument.  ",
  "widen_mult_hi_expr": " Widening vector multiplication.  \n   The two operands are vectors with N elements of size S. Multiplying the  \n   elements of the two vectors will result in N products of size 2*S.  \n   VEC_WIDEN_MULT_HI_EXPR computes the N/2 high products.  \n   VEC_WIDEN_MULT_LO_EXPR computes the N/2 low products.  ",
  "widen_mult_lo_expr": " Widening vector multiplication.  \n   The two operands are vectors with N elements of size S. Multiplying the  \n   elements of the two vectors will result in N products of size 2*S.  \n   VEC_WIDEN_MULT_HI_EXPR computes the N/2 high products.  \n   VEC_WIDEN_MULT_LO_EXPR computes the N/2 low products.  ",
  "widen_mult_even_expr": " Similarly, but return the even or odd N/2 products.  ",
  "widen_mult_odd_expr": " Similarly, but return the even or odd N/2 products.  ",
  "vec_unpack_hi_expr": " Unpack (extract and promote/widen) the high/low elements of the input  \n   vector into the output vector.  The input vector has twice as many  \n   elements as the output vector, that are half the size of the elements  \n   of the output vector.  This is used to support type promotion. ",
  "vec_unpack_lo_expr": " Unpack (extract and promote/widen) the high/low elements of the input  \n   vector into the output vector.  The input vector has twice as many  \n   elements as the output vector, that are half the size of the elements  \n   of the output vector.  This is used to support type promotion. ",
  "vec_unpack_float_hi_expr": " Unpack (extract) the high/low elements of the input vector, convert  \n   fixed point values to floating point and widen elements into the  \n   output vector.  The input vector has twice as many elements as the output  \n   vector, that are half the size of the elements of the output vector.  ",
  "vec_unpack_float_lo_expr": " Unpack (extract) the high/low elements of the input vector, convert  \n   fixed point values to floating point and widen elements into the  \n   output vector.  The input vector has twice as many elements as the output  \n   vector, that are half the size of the elements of the output vector.  ",
  "vec_unpack_fix_trunc_hi_expr": " Unpack (extract) the high/low elements of the input vector, convert  \n   floating point values to integer and widen elements into the output  \n   vector.  The input vector has twice as many elements as the output  \n   vector, that are half the size of the elements of the output vector.  ",
  "vec_unpack_fix_trunc_lo_expr": " Unpack (extract) the high/low elements of the input vector, convert  \n   floating point values to integer and widen elements into the output  \n   vector.  The input vector has twice as many elements as the output  \n   vector, that are half the size of the elements of the output vector.  ",
  "vec_pack_trunc_expr": " Pack (demote/narrow and merge) the elements of the two input vectors  \n   into the output vector using truncation/saturation.  \n   The elements of the input vectors are twice the size of the elements of the  \n   output vector.  This is used to support type demotion.  ",
  "vec_pack_sat_expr": " Pack (demote/narrow and merge) the elements of the two input vectors  \n   into the output vector using truncation/saturation.  \n   The elements of the input vectors are twice the size of the elements of the  \n   output vector.  This is used to support type demotion.  ",
  "vec_pack_fix_trunc_expr": " Convert floating point values of the two input vectors to integer  \n   and pack (narrow and merge) the elements into the output vector. The  \n   elements of the input vector are twice the size of the elements of  \n   the output vector.  ",
  "vec_pack_float_expr": " Convert fixed point values of the two input vectors to floating point  \n   and pack (narrow and merge) the elements into the output vector. The  \n   elements of the input vector are twice the size of the elements of  \n   the output vector.  ",
  "widen_lshift_hi_expr": " Widening vector shift left in bits.  \n   Operand 0 is a vector to be shifted with N elements of size S.  \n   Operand 1 is an integer shift amount in bits.  \n   The result of the operation is N elements of size 2*S.  \n   VEC_WIDEN_LSHIFT_HI_EXPR computes the N/2 high results.  \n   VEC_WIDEN_LSHIFT_LO_EXPR computes the N/2 low results.",
  "widen_lshift_lo_expr": " Widening vector shift left in bits.  \n   Operand 0 is a vector to be shifted with N elements of size S.  \n   Operand 1 is an integer shift amount in bits.  \n   The result of the operation is N elements of size 2*S.  \n   VEC_WIDEN_LSHIFT_HI_EXPR computes the N/2 high results.  \n   VEC_WIDEN_LSHIFT_LO_EXPR computes the N/2 low results.",
  "predict_expr": " PREDICT_EXPR.  Specify hint for branch prediction.  The  \n   PREDICT_EXPR_PREDICTOR specify predictor and PREDICT_EXPR_OUTCOME the  \n   outcome (0 for not taken and 1 for taken).  Once the profile is guessed  \n   all conditional branches leading to execution paths executing the  \n   PREDICT_EXPR will get predicted by the specified predictor.  ",
  "optimization_node": " OPTIMIZATION_NODE.  Node to store the optimization options.  ",
  "target_option_node": " TARGET_OPTION_NODE.  Node to store the target specific options.  ",
  "annotate_expr": " ANNOTATE_EXPR.  \n   Operand 0 is the expression to be annotated.  \n   Operand 1 is the annotation kind.  \n   Operand 2 is additional data.  "
}